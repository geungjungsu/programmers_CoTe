# A : FRONT END + PYTHON
# C#
# C : 그 외에 FRONE END

# GRADE가 존재하는 개발자의
# GRADE
# ID
# EMAIL
# GRADE와 ID기준 오름차순



SELECT 
CASE 
    WHEN (GROUP_CONCAT(S.NAME) LIKE '%Python%' AND
          GROUP_CONCAT(S.CATEGORY) LIKE '%Front End%'
    ) THEN 'A'
    WHEN GROUP_CONCAT(S.NAME) LIKE '%C#%' THEN 'B'
    WHEN GROUP_CONCAT(S.CATEGORY) LIKE '%Front End%' THEN 'C'
    END AS GRADE
, D.ID, D.EMAIL
FROM DEVELOPERS AS D
INNER JOIN SKILLCODES AS S 
ON D.SKILL_CODE & S.CODE = S.CODE
GROUP BY D.ID, D.EMAIL
HAVING GRADE IS NOT NULL
ORDER BY GRADE,ID ASC
;




